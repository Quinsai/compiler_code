# 错误处理

## 三大类的错误

实际上存在三大类的错误

1. 词法错误
2. 语法错误
3. 语义错误

## 报错类型表

总体上就是平台上的表格，只是在最后加入了一些东西

| **错误类型**                 | **错误类别码** | **解释**                                                                                | **对应文法及出错符号( … 表示省略该条规则后续部分)**                                                                                                                                                                    | 错误类型 | 需要如何处理                                             |
| ------------------------ | --------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- | -------------------------------------------------- |
| 非法符号                     | a         | 格式字符串中出现非法字符报错行号为 &lt;FormatString&gt; 所在行数。                                          | &lt;FormatString&gt; → ‘“‘{&lt;Char&gt;}’”                                                                                                                                                        | 语义错误 | 不需要符号表和语法分析树，仅仅需要一个单独的处理函数即可                       |
| 名字重定义                    | b         | 函数名或者变量名在当前作用域下重复定义。注意，变量一定是同一级作用域下才会判定出错，不同级作用域下，内层会覆盖外层定义。报错行号为 &lt;Ident&gt; 所在行数。 | &lt;ConstDef&gt;→&lt;Ident&gt; … <br> &lt;VarDef&gt;→&lt;Ident&gt; … &lt;Ident&gt; … <br> &lt;FuncDef&gt;→&lt;FuncType&gt;&lt;Ident&gt; … <br> &lt;FuncFParam&gt; → &lt;BType&gt; &lt;Ident&gt; … | 语义错误 | 需要符号表，符号表在中要有一个属性表示当前的标识符是定义在哪一个作用域的（区分不同作用域的方法再议） |
| 未定义的名字                   | c         | 使用了未定义的标识符报错行号为 &lt;Ident&gt; 所在行数。                                                   | &lt;LVal&gt;→&lt;Ident&gt; … <br> &lt;UnaryExp&gt;→&lt;Ident&gt; …                                                                                                                                | 语义错误 | 需要符号表，主要的问题是要保证每一时刻的符号表中的所有标识符都是当前这个语句中可用的         |
| 函数参数个数不匹配                | d         | 函数调用语句中，参数个数与函数定义中的参数个数不匹配。报错行号为函数调用语句的函数名所在行数。                                       | &lt;UnaryExp&gt;→&lt;Ident&gt;‘(’[FuncRParams ]‘)’                                                                                                                                                | 语义错误 | 需要符号表，符号表中要存在一个子表，子表中包含函数参数列表，列表中有参数的类型和形式名        |
| 函数参数类型不匹配                | e         | 函数调用语句中，参数类型与函数定义中对应位置的参数类型不匹配。报错行号为函数调用语句的函数名所在行数。                                   | &lt;UnaryExp&gt;→&lt;Ident&gt;‘(’[FuncRParams ]‘)’                                                                                                                                                | 语义错误 | 同上                                                 |
| 无返回值的函数存在不匹配的return语句    | f         | 报错行号为 ‘return’ 所在行号。                                                                  | &lt;Stmt&gt;→‘return’ {‘[’Exp’]’}‘;’                                                                                                                                                              | 语义错误 | 需要符号表，符号表中要存在一个子表，子表中包含函数的返回情况                     |
| 有返回值的函数缺少return语句        | g         | 只需要考虑函数末尾是否存在return语句，无需考虑数据流。报错行号为函数结尾的’}’ 所在行号。                                     | &lt;FuncDef&gt; → &lt;FuncType&gt; &lt;Ident&gt; ‘(’ [&lt;FuncFParams&gt;] ‘)’ &lt;Block&gt; <br> &lt;MainFuncDef&gt; → ‘int’ ‘main’ ‘(’ ‘)’ &lt;Block&gt;                                        | 语义错误 | 同上                                                 |
| 不能改变常量的值                 | h         | &lt;LVal&gt;为常量时，不能对其修改。报错行号为 &lt;LVal&gt; 所在行号。                                      | &lt;Stmt&gt;→&lt;LVal&gt;‘=’ &lt;Exp&gt;‘;’ <br> &lt;Stmt&gt;→&lt;LVal&gt;‘=’ ‘getint’ ‘(’ ‘)’ ‘;’                                                                                                | 语义错误 | 需要符号表，符号表的主表里面有这个变量是否是常量的一个指标                      |
| 缺少分号                     | i         | 报错行号为分号前一个非终结符所在行号。                                                                   | &lt;Stmt&gt;,&lt;ConstDecl&gt;及&lt;VarDecl&gt;中的’;’                                                                                                                                               | 语法错误 | 不需要符号表和语法分析树，仅仅在相应的分析器中添加一个错误处理即可                  |
| 缺少右小括号’)’                | j         | 报错行号为右小括号前一个非终结符所在行号。                                                                 | 函数调用(&lt;UnaryExp&gt;)、函数定义(&lt;FuncDef&gt;)及&lt;Stmt&gt;中的’)’                                                                                                                                    | 语法错误 | 同上                                                 |
| 缺少右中括号’]’                | k         | 报错行号为右中括号前一个非终结符所在行号。                                                                 | 数组定义(&lt;ConstDef&gt;,&lt;VarDef&gt;,&lt;FuncFParam&gt;)和使用(&lt;LVal&gt;)中的’]’                                                                                                                    | 语法错误 | 同上                                                 |
| printf中格式字符与表达式个数不匹配     | l         | 报错行号为 ‘printf’ 所在行号。                                                                  | &lt;Stmt&gt; →‘printf’‘(’&lt;FormatString&gt;{,&lt;Exp&gt;}’)’‘;’                                                                                                                                 | 语义错误 | 不需要符号表和语法分析树，仅仅在Stmt的该分支下加一个判断错误的函数                |
| 在非循环块中使用break和continue语句 | m         | 报错行号为 ‘break’ 与 ’continue’ 所在行号。                                                      | &lt;Stmt&gt;→‘break’‘;’&lt;Stmt&gt;→‘continue’‘;’                                                                                                                                                 | 语义错误 | 不需要符号表和语法分析树，仅仅需要给Stmt的分析程序加一个是否在循环中的参数即可          |

## 错误处理及其前序设计

基于上面表格中的分析，得出如下暂时性的结论

- 语法分析树依旧可以暂时不建立
- 符号表必须构建
  - `主表 + 子表` 的模式
    - 主表：符号名（作为ID），种类（变量、常量、函数），类型（int, 数组），到子表的连接
    - 函数子表
    - 数组子表
  - 分程序索引表

> 最新发现：语法分析树哪怕是在实验的期中考试也依旧可以不建立，赢！

## 符号表构造

**符号表构造的过程中走了一些弯路**，由此产生了下面的问题：

符号表构造中我究竟需要做什么，不需要做什么

- Q: 我需要在`EXP`和`ConstExp`中求值吗？

- A: 不需要，也不可能完全实现。像获取函数的返回值这样的要求在语义分析之前是不可能完成的。

- Q: 我需要真的实现赋值操作吗？

- A: 不需要，也不可能完全实现。像获取函数的返回值这样的要求在语义分析之前是不可能完成的。

- Q: 我可能知道数组各个维度的大小吗？

- A: 由问题一可知，目前不可能实现。

所以，我在符号表构造中我需要考虑的只有

> 注意，这里依旧保持走弯路中的思路，即把声明和赋值强分开
> 
> ```
> int a = 2;
> ```
> 
> 也就是像这样的源代码，依旧将其视为两步处理
> 
> 1. 声明变量`a`
> 
> 2. 给`a`赋值2

- 声明的时候
  
  - 该标识符名字是否已经在同一作用域下被定义

- 赋值的时候
  
  - 是否试图给不是`VAR`类型（变量）类型的东西赋值
  
  - 是否试图给不存在的赋值

- 引用的时候
  
  - 是否已经被声明



## 错误局部化

错误局部化出于这样的一种考虑，**一行中错误仅仅会有一种**，和**所有错误都不会出现恶意换行的情况**。那么我就可以在读取到某一行中的错误的时候，跳过这一行，直接进入下一行的处理。

涉及到的文法如下

```
ConstDecl → 'const' BType ConstDef { ',' ConstDef } ';'
VarDecl → BType VarDef { ',' VarDef } ';'
Stmt → LVal '=' Exp ';'
    | [Exp] ';'
    | Block
    | 'if' '(' Cond ')' Stmt [ 'else' Stmt ]
    | 'for' '(' [ForStmt] ';' [Cond] ';' [ForStmt] ')' Stmt
    | 'break' ';' 
    | 'continue' ';'
    | 'return' [Exp] ';'
    | LVal '=' 'getint''('')'';'
    | 'printf''('FormatString{','Exp}')'';'
Block → '{' { BlockItem } '}'
```

那么解决的思路就是

出错的语法成分不断向上报错，直到报错到上面的四条之一，随后在上面的四条中实现直接进入下一行
